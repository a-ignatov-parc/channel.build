#!/usr/bin/env ruby

require 'rubygems'
require 'bundler/setup'
Bundler.require(:default, ENV['CHAN_ENV'] || :development)

# TODO:
# - Move modules/classes to separate files, build src to single exe script.
# - Implement better error messages and logging.
module CaffeineLabs
  module Utility
    # NOTE: http://stackoverflow.com/a/30225093/1211780
    def self.deep_merge(a, b)
        merger = proc { |key, v1, v2| Hash === v1 && Hash === v2 ? v1.merge(v2, &merger) : Array === v1 && Array === v2 ? v1 | v2 : [:undefined, nil, :nil].include?(v2) ? v1 : v2 }
        a.merge(b.to_h, &merger)
    end

    # NOTE: http://stackoverflow.com/a/3450848/1211780
    def self.compact(h)
      compacter = proc { |k, v| v.kind_of?(Hash) ? (v.delete_if(&compacter); nil) : v.nil? }
      h.delete_if(&compacter)
    end

    def self.files_replace(file_paths, regex, substitute)
      file_paths.select(&:file?).each do |path|
        content = IO.readlines(path)
                    .map { |line| line.gsub(regex, substitute) }
                    .join('')
        File.write(path, content)
      end
    end

    def self.rename_recursive(path, regex, substitute)
      basename = path.basename.to_s.gsub(regex, substitute)
      new_path = path.dirname.join(basename)
      FileUtils.mv(path.to_s, new_path.to_s) if path != new_path
      if new_path.directory?
        Dir.glob("#{new_path}/*").each { |p| rename_recursive(Pathname.new(p), regex, substitute) }
      end
    end

    def self.increment_path(path)
      n = 1
      new_path = path
      while new_path.exist? do
        new_path = path.file? ? path.parent.join("#{path.basename(path.extname)}_#{n}#{path.extname}") :
                                path.parent.join("#{path.basename}_#{n}")
        n += 1
      end
      new_path
    end
  end

  class Chan < Thor
    # TODO: Move config to external yaml file.
    @@config = OpenStruct.new(
      :api_url => ENV['CHAN_API_URL'] || 'http://channel.build/api/',
      :manifest_basename => 'manifest.plist',
      :assets_dirname => 'assets',
      :recipe_extname => '.chr',
      :icon_small_basename => 'icon-small.png',
      :icon_large_basename => 'icon-large.png',
      :icon_topshelf_basename => 'icon-topshelf.png',

      :manifest_properties => {
        'Recipe Version' => '1.0',
        'Organization Name' => 'CaffeineLabs',
        'Organization Identifier' => 'com.caffeinelabs'
      },

      :project_settings => OpenStruct.new(
        :local_client_url => 'http://localhost:1337/'
      ),

      :create => OpenStruct.new(
        :output_path => Dir.getwd(),
        :tvjs_client_url => 'http://channel-staging.heroku.com/',
        :tvjs_app_path => 'app.js',
        :web_api_url => 'http://channel.build/api/',
        :icon_small_url => 'placehold.it/400x240',
        :icon_large_url => 'placehold.it/1280x768',
        :icon_topshelf_url => 'placehold.it/1920x720'
      ),

      :generate => OpenStruct.new(
        :output_path => Dir.getwd(),
        :channel_project_path => './project',
        :channel_project_name => 'channel'
      )
    )

    def self.config
      @@config
    end

    def self.create_manifest(options = {})
      manifest_properties = {
        'Author Properties' => {
          'ID'              => options.fetch(:author_id)
        },
        'Channel Properties' => {
          'ID'              => options.fetch(:channel_id),
          'Name'            => options.fetch(:channel_name),
          'Description'     => options.fetch(:channel_desc),
          'TVJS Client URL' => options.fetch(:tvjs_client_url),
          'TVJS App Path'   => options.fetch(:tvjs_app_path),
          'Web API URL'     => options.fetch(:web_api_url)
        },
        'Assets' => {
          'App Icons' => {
            'App Icon - Small' => {
              'Back'   => "#{@@config.assets_dirname}/#{@@config.icon_small_basename}",
              'Middle' => "#{@@config.assets_dirname}/#{@@config.icon_small_basename}",
              'Front'  => "#{@@config.assets_dirname}/#{@@config.icon_small_basename}"
            },
            'App Icon - Large' => {
              'Back'   => "#{@@config.assets_dirname}/#{@@config.icon_large_basename}",
              'Middle' => "#{@@config.assets_dirname}/#{@@config.icon_large_basename}",
              'Front'  => "#{@@config.assets_dirname}/#{@@config.icon_large_basename}"
            },
            'Top Shelf Image' => "#{@@config.assets_dirname}/#{@@config.icon_topshelf_basename}"
          }
        }
      }

      Utility.deep_merge(
        @@config.manifest_properties,
        Utility.compact(manifest_properties)
      ).to_plist
    end

    desc 'create <channel_id>',
         'Creates a channel recipe by fetching channel information from the Web API and saving it in the filesystem.'
    method_option 'output', type: :string, desc: 'Output path', aliases: '-o',
                  default: @@config.create.output_path
    method_option 'jsurl', type: :string, desc: 'TVJS client URL',
                  default: @@config.create.tvjs_client_url
    method_option 'jspath', type: :string, desc: 'TVJS application path',
                  default: @@config.create.tvjs_app_path
    method_option 'apiurl', type: :string, desc: 'Web API URL',
                  default: @@config.create.web_api_url
    def create(channel_id)
      # Get the channel info from Web API using channel ID.
      all_channels_url = URI.parse("#{@@config.api_url}admin").to_s
      puts "--- Requesting GET #{all_channels_url}...".yellow
      all_channels_response = RestClient.get(all_channels_url)
      all_channels = JSON.parse(all_channels_response.body)
      if (channel_index = all_channels.index { |c| c['_id'] == channel_id }).nil?
        raise ArgumentError.new("--- Channel with ID #{channel_id} is not found in response to GET #{all_channels_url}!")
      end
      channel = all_channels[channel_index]
      ap channel

      # Create content of manifest file from Web API response and provided options.
      puts "--- Found a channel with ID #{channel_id}. Generating a manifest...".yellow
      manifest_content = Chan.create_manifest(
        :author_id => channel['userId'],
        :channel_id => channel['_id'],
        :channel_name => channel['name'],
        :channel_desc => channel['description'],
        :tvjs_client_url => options[:jsurl],
        :tvjs_app_path => options[:jspath],
        :web_api_url => options[:apiurl]
      )

      # Request images and save them in memory.
      assets_urls = OpenStruct.new(
        :icon_small => channel['assets_icon_small'] || @@config.create.icon_small_url,
        :icon_large => channel['assets_icon_big'] || @@config.create.icon_large_url,
        :icon_topshelf => channel['assets_banner'] || @@config.create.icon_topshelf_url
      )

      puts "--- Requesting small icon GET #{assets_urls.icon_small}...".yellow
      icon_small_response = RestClient.get(assets_urls.icon_small, :accept => 'image/*')
      icon_small = OpenStruct.new(
        :content => icon_small_response.body,
        :basename => "#{@@config.icon_small_basename}"
      )

      puts "--- Requesting large icon GET #{assets_urls.icon_large}...".yellow
      icon_large_response = RestClient.get(assets_urls.icon_large, :accept => 'image/*')
      icon_large = OpenStruct.new(
        :content => icon_large_response.body,
        :basename => "#{@@config.icon_large_basename}"
      )

      puts "--- Requesting top shelf icon GET #{assets_urls.icon_topshelf}...".yellow
      icon_topshelf_response = RestClient.get(assets_urls.icon_topshelf, :accept => 'image/*')
      icon_topshelf = OpenStruct.new(
        :content => icon_topshelf_response.body,
        :basename => "#{@@config.icon_topshelf_basename}"
      )

      # Form the path for the recipe. If filename is not presented in the path parameter,
      # use name of the channel without spaces as filename.
      recipe_filename = channel['name'].gsub(/\s+/, '')
      output_path = Pathname.new(options[:output]).expand_path
      output_path = output_path.join("#{recipe_filename}#{@@config.recipe_extname}") if output_path.directory?
      output_path = Utility.increment_path(output_path) if output_path.exist?
      puts "--- Saving the recipe to #{output_path}...".yellow

      # Use temp directory to create an archive.
      Dir.mktmpdir do |path|
        temp_path = Pathname.new(path).expand_path
        assets_path = temp_path.join(@@config.assets_dirname)
        manifest_path = temp_path.join(@@config.manifest_basename)
        FileUtils.mkpath(temp_path)
        FileUtils.mkpath(assets_path)
        File.write(manifest_path, manifest_content)
        File.write(assets_path.join(icon_small.basename), icon_small.content)
        File.write(assets_path.join(icon_large.basename), icon_large.content)
        File.write(assets_path.join(icon_topshelf.basename), icon_topshelf.content)

        # Create zip archive with manifest and assets - the recipe.
        Zip::Archive.open(output_path.to_s, Zip::CREATE | Zip::TRUNC) do |ar|
          Dir.glob(temp_path.join('**/*').to_s).each do |p|
            absolute_path = Pathname.new(p).expand_path
            relative_path = absolute_path.relative_path_from(temp_path)
            if absolute_path.directory?
              ar.add_dir(relative_path.to_s)
            else
              ar.add_file(relative_path.to_s, absolute_path.to_s)
            end
          end
        end
      end

      puts "--- Done!".green
      exit 0
    end

    desc 'generate <recipe_path>',
         'Generates Xcode project from channel recipe.'
    method_option 'output', type: :string, desc: 'Output path', aliases: '-o',
                  default: @@config.generate.output_path
    method_option 'project', type: :string, desc: 'Channel project path', aliases: '-p',
                  default: @@config.generate.channel_project_path
    def generate(recipe_path)
      recipe_path = Pathname.new(recipe_path).expand_path

      # Create temp directory.
      Dir.mktmpdir do |path|
        temp_path = Pathname.new(path).expand_path
        assets_path = temp_path.join(@@config.assets_dirname)
        manifest_path = temp_path.join(@@config.manifest_basename)
        puts "--- Unpacking the recipe #{recipe_path} to temp directory #{temp_path}...".yellow

        # Unzip recipe into temp directory.
        Zip::Archive.open(recipe_path.to_s) do |ar|
          ar.each do |zf|
            zf_path = temp_path.join(zf.name)
            if zf.directory?
              FileUtils.mkpath(zf_path)
            else
              FileUtils.mkpath(zf_path.dirname) unless zf_path.dirname.exist?
              File.write(zf_path, zf.read)
            end
          end
        end

        # Throw an error if there is no manifest in the archive.
        if !manifest_path.exist?
          raise ArgumentError.new("--- Manifest file `#{@@config.manifest_basename}` is missing in the recipe!")
        end

        # Read the manifest.
        puts "--- Found a manifest `#{@@config.manifest_basename}`. Reading the manifest...".yellow
        manifest = Plist::parse_xml(manifest_path)
        channel_properties = manifest['Channel Properties']
        channel_id, tvjs_client_url, tvjs_app_path, web_api_url =
          channel_properties.values_at('ID', 'TVJS Client URL', 'TVJS App Path', 'Web API URL')
        ap manifest

        # Copy Channel project to the output directory.
        channel_project_name = @@config.generate.channel_project_name
        channel_project_path = Pathname.new(options[:project]).expand_path
        channel_project_files = Dir.glob(channel_project_path.join("#{channel_project_name}*"))
        product_name = manifest['Channel Properties']['Name']
        project_name = product_name.gsub(/\s+/, '')
        project_path = Pathname.new(options[:output]).expand_path.join(project_name)
        project_path = Utility.increment_path(project_path) if project_path.exist?
        project_package_path = project_path.join("#{channel_project_name}.xcodeproj")
        puts "--- Copying Channel project from #{channel_project_path} to #{project_path}...".yellow

        # Throw an error if Channel project doesn't exist at the given path.
        if channel_project_files.grep(/#{channel_project_name}\.xcodeproj$/).empty?
          raise StandardError.new("--- Channel project `#{channel_project_name}.xcodeproj` is not found at #{channel_project_path}")
        end

        FileUtils.mkpath(project_path)
        FileUtils.cp_r(channel_project_files, project_path)

        # Remove user data from new project.
        puts "--- Removing user data from .xcodeproj...".yellow
        Dir.glob(project_path.join("#{channel_project_name}.xcodeproj/**/xcuserdata"))
                             .map(&project_package_path.method(:join))
                             .each(&FileUtils.method(:rmtree))

        # Replace all occurences of Channel project name with new project name in project files.
        puts "--- Renaming project from `#{channel_project_name}` to `#{project_name}`...".yellow
        replace_regex = /\b#{channel_project_name}\b/
        project_paths = Dir.glob(project_path.join("**/*"))
                           .map(&Pathname.method(:new))
        Utility.files_replace(project_paths, replace_regex, project_name)

        # Change project settings.
        puts "--- Updating project settings with manifest values...".yellow
        project = Xcodeproj::Project.open(project_package_path)

        debug_settings = project.build_configuration_list['Debug'].build_settings
        release_settings = project.build_configuration_list['Release'].build_settings
        debug_staging_settings = project.build_configuration_list['Debug Staging'].build_settings
        release_staging_settings = project.build_configuration_list['Release Staging'].build_settings
        development_project_settings = {
          'CL_CHANNEL_ID' => channel_id,
          'CL_TVJS_CLIENT_URL' => @@config.project_settings.local_client_url,
          'CL_TVJS_APP_PATH' => tvjs_app_path,
          'CL_WEB_API_URL' => web_api_url
        }
        staging_project_settings = development_project_settings.merge({
          'CL_TVJS_CLIENT_URL' => tvjs_client_url
        })

        debug_settings.merge!(development_project_settings)
        release_settings.merge!(development_project_settings)
        debug_staging_settings.merge!(staging_project_settings)
        release_staging_settings.merge!(staging_project_settings)

        product = project.products[0]
        target = project.targets[0]
        target.name = target.product_name = product.name = product_name
        product.path = "#{product_name}.app"

        project.save

        # Rename project files.
        rename_regex = /#{channel_project_name}/
        Utility.rename_recursive(project_path, rename_regex, project_name)
      end

      puts "--- Done!".green
      exit 0
    end
  end
end

begin
  CaffeineLabs::Chan.start(ARGV)
rescue => e
  abort(e.message.red)
end
