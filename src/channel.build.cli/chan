#!/usr/bin/env ruby

require 'rubygems'
require 'bundler/setup'
Bundler.require(:default, ENV['CHAN_ENV']  || :development)

# TODO:
# - Move modules/classes to separate files, build src to single exe script.
# - Implement better error messages and logging.
module CaffeineLabs
  module Utility
    # NOTE: http://stackoverflow.com/a/30225093/1211780
    def self.deep_merge(a, b)
        merger = proc { |key, v1, v2| Hash === v1 && Hash === v2 ? v1.merge(v2, &merger) : Array === v1 && Array === v2 ? v1 | v2 : [:undefined, nil, :nil].include?(v2) ? v1 : v2 }
        a.merge(b.to_h, &merger)
    end

    # NOTE: http://stackoverflow.com/a/3450848/1211780
    def self.compact(h)
      compacter = proc { |k, v| v.kind_of?(Hash) ? (v.delete_if(&compacter); nil) : v.nil? }
      h.delete_if(&compacter)
    end

    def self.files_replace(file_paths, regex, substitute)
      file_paths.select(&:file?).each do |path|
        content = IO.readlines(path)
                    .map { |line| line.gsub(regex, substitute) }
                    .join('')
        File.write(path, content)
      end
    end

    def self.rename_recursive(path, regex, substitute)
      basename = path.basename.to_s.gsub(regex, substitute)
      new_path = path.dirname.join(basename)
      FileUtils.mv(path.to_s, new_path.to_s) if path != new_path
      if new_path.directory?
        Dir.glob("#{new_path}/*").each { |p| rename_recursive(Pathname.new(p), regex, substitute) }
      end
    end
  end

  class Chan < Thor
    # TODO: Move config to external yaml file.
    @@config = OpenStruct.new(
      :api_url => ENV['CHAN_API_URL'] || 'http://channel.build/api/',
      :manifest_filename => 'manifest.plist',
      :assets_dirname => 'assets',
      :recipe_extname => '.chr',

      :manifest_properties => {
        'Recipe Version' => '1.0',
        'Organization Name' => 'CaffeineLabs',
        'Organization Identifier' => 'com.caffeinelabs'
      },

      :project_settings => OpenStruct.new(
        :local_client_url => 'http://localhost:1337/'
      ),

      :create => OpenStruct.new(
        :output_path => Dir.getwd(),
        :tvjs_client_url => 'http://channel-staging.heroku.com/',
        :tvjs_app_path => 'app.js',
        :web_api_url => 'http://channel.build/api/'
      ),

      :generate => OpenStruct.new(
        :output_path => Dir.getwd(),
        :channel_project_path => './project',
        :channel_project_name => 'channel'
      )
    )

    def self.config
      @@config
    end

    def self.create_manifest(options = {})
      manifest_properties = {
        'Author Properties' => {
          'ID'              => options.fetch(:author_id)
        },
        'Channel Properties' => {
          'ID'              => options.fetch(:channel_id),
          'Name'            => options.fetch(:channel_name),
          'Description'     => options.fetch(:channel_desc),
          'TVJS Client URL' => options.fetch(:tvjs_client_url),
          'TVJS App Path'   => options.fetch(:tvjs_app_path),
          'Web API URL'     => options.fetch(:web_api_url)
        }
      }

      Utility.deep_merge(
        @@config.manifest_properties,
        Utility.compact(manifest_properties)
      ).to_plist
    end

    desc 'create <channel_id>',
         'Creates a channel recipe by fetching channel information from the Web API and saving it in the filesystem.'
    method_option 'output', type: :string, desc: 'Output path', aliases: '-o',
                  default: @@config.create.output_path
    method_option 'jsurl', type: :string, desc: 'TVJS client URL',
                  default: @@config.create.tvjs_client_url
    method_option 'jspath', type: :string, desc: 'TVJS application path',
                  default: @@config.create.tvjs_app_path
    method_option 'apiurl', type: :string, desc: 'Web API URL',
                  default: @@config.create.web_api_url
    def create(channel_id)
      # Get the channel info from Web API using channel ID.
      all_channels_url = URI.parse("#{@@config.api_url}admin").to_s
      puts "--- Requesting GET #{all_channels_url}...".yellow
      all_channels_response = RestClient.get(all_channels_url)
      all_channels = JSON.parse(all_channels_response.body)
      if (channel_index = all_channels.index { |c| c['_id'] == channel_id }).nil?
        raise ArgumentError.new("--- Channel with ID #{channel_id} is not found in response to GET #{all_channels_url}!")
      end
      channel = all_channels[channel_index]

      # Create content of manifest file from Web API response and provided options.
      puts "--- Found a channel with ID #{channel_id}. Generating a manifest...".yellow
      manifest_content = Chan.create_manifest(
        :author_id => channel['userId'],
        :channel_id => channel['_id'],
        :channel_name => channel['name'],
        :channel_desc => channel['description'],
        :tvjs_client_url => options[:jsurl],
        :tvjs_app_path => options[:jspath],
        :web_api_url => options[:apiurl]
      )

      # Form the path for the recipe. If filename is not presented in the path parameter,
      # use name of the channel without spaces as filename.
      recipe_filename = channel['name'].gsub(/\s+/, '')
      output_path = Pathname.new(options[:output]).expand_path
      output_path = output_path.join("#{recipe_filename}#{@@config.recipe_extname}") if output_path.directory?
      puts "--- Saving the recipe to #{output_path}...".yellow

      # Create the directory and temp folder for zip archive.
      temp_path = output_path.dirname.join(output_path.basename(output_path.extname))
      assets_path = temp_path.join(@@config.assets_dirname)
      manifest_path = temp_path.join(@@config.manifest_filename)
      FileUtils.mkpath(temp_path)
      FileUtils.mkpath(assets_path)
      File.write(manifest_path, manifest_content)

      # Create zip archive with manifest and assets - the recipe.
      Zip::Archive.open(output_path.to_s, Zip::CREATE | Zip::TRUNC) do |ar|
        Dir.glob(temp_path.join('**/*').to_s).each do |path|
          absolute_path = Pathname.new(path).expand_path
          relative_path = absolute_path.relative_path_from(temp_path)
          if absolute_path.directory?
            ar.add_dir(relative_path.to_s)
          else
            ar.add_file(relative_path.to_s, absolute_path.to_s)
          end
        end
      end

      # Remove temp directory.
      puts "--- Cleaning up...".yellow
      FileUtils.rmtree(temp_path)

      puts "--- Done!".green
      exit 0
    end

    desc 'generate <recipe_path>',
         'Generates Xcode project from channel recipe.'
    method_option 'output', type: :string, desc: 'Output path', aliases: '-o',
                  default: @@config.generate.output_path
    method_option 'project', type: :string, desc: 'Channel project path', aliases: '-p',
                  default: @@config.generate.channel_project_path
    def generate(recipe_path)
      recipe_path = Pathname.new(recipe_path).expand_path

      # Create temp directory.
      Dir.mktmpdir do |path|
        temp_path = Pathname.new(path).expand_path
        assets_path = temp_path.join(@@config.assets_dirname)
        manifest_path = temp_path.join(@@config.manifest_filename)
        puts "--- Unpacking the recipe #{recipe_path} to temp directory #{temp_path}...".yellow

        # Unzip recipe into temp directory.
        Zip::Archive.open(recipe_path.to_s) do |ar|
          ar.each do |zf|
            zf_path = temp_path.join(zf.name)
            if zf.directory?
              FileUtils.mkpath(zf_path)
            else
              FileUtils.mkpath(zf_path.dirname) unless zf_path.dirname.exist?
              File.write(zf_path, zf.read)
            end
          end
        end

        # Throw an error if there is no manifest in the archive.
        if !manifest_path.exist?
          raise ArgumentError.new("--- Manifest file `#{@@config.manifest_filename}` is missing in the recipe!")
        end

        # Read the manifest.
        puts "--- Found a manifest `#{@@config.manifest_filename}`. Reading the manifest...".yellow
        manifest = Plist::parse_xml(manifest_path)
        channel_properties = manifest['Channel Properties']
        channel_id, tvjs_client_url, tvjs_app_path, web_api_url =
          channel_properties.values_at('ID', 'TVJS Client URL', 'TVJS App Path', 'Web API URL')
        ap manifest

        # Copy Channel project to the output directory.
        channel_project_name = @@config.generate.channel_project_name
        channel_project_path = Pathname.new(options[:project]).expand_path
        channel_project_files = Dir.glob(channel_project_path.join("#{channel_project_name}*"))
        project_name = manifest['Channel Properties']['Name'].gsub(/\s+/, '')
        project_path = Pathname.new(options[:output]).expand_path.join(project_name)
        project_package_path = project_path.join("#{channel_project_name}.xcodeproj")
        puts "--- Copying Channel project from #{channel_project_path} to #{project_path}...".yellow

        # Throw an error if Channel project doesn't exist at the given path.
        if channel_project_files.grep(/#{channel_project_name}\.xcodeproj$/).empty?
          raise StandardError.new("--- Channel project `#{channel_project_name}.xcodeproj` is not found at #{channel_project_path}")
        end

        FileUtils.mkpath(project_path)
        FileUtils.cp_r(channel_project_files, project_path)

        # Remove user data from new project.
        puts "--- Removing user data from .xcodeproj...".yellow
        Dir.glob(project_path.join("#{channel_project_name}.xcodeproj/**/xcuserdata"))
                             .map(&project_package_path.method(:join))
                             .each(&FileUtils.method(:rmtree))

        # Replace all occurences of Channel project name with new project name in project files.
        puts "--- Renaming project from `#{channel_project_name}` to `#{project_name}`...".yellow
        replace_regex = /\b#{channel_project_name}\b/
        project_paths = Dir.glob(project_path.join("**/*"))
                           .map(&Pathname.method(:new))
        Utility.files_replace(project_paths, replace_regex, project_name)

        # Change project settings.
        puts "--- Updating project settings with manifest values...".yellow
        project = Xcodeproj::Project.open(project_package_path)

        debug_settings = project.build_configuration_list['Debug'].build_settings
        release_settings = project.build_configuration_list['Release'].build_settings
        debug_staging_settings = project.build_configuration_list['Debug Staging'].build_settings
        release_staging_settings = project.build_configuration_list['Release Staging'].build_settings
        development_project_settings = {
          'TV_CHANNEL_ID' => channel_id,
          'TV_HOST_URL' => @@config.project_settings.local_client_url,
          'TV_BOOT_URL' => "$(TV_HOST_URL)#{tvjs_app_path}",
          'TV_API_URL' => web_api_url
        }
        staging_project_settings = development_project_settings.merge({
          'TV_HOST_URL' => tvjs_client_url
        })

        debug_settings.merge!(development_project_settings)
        release_settings.merge!(development_project_settings)
        debug_staging_settings.merge!(staging_project_settings)
        release_staging_settings.merge!(staging_project_settings)

        project.save

        # Rename project files.
        rename_regex = /#{channel_project_name}/
        Utility.rename_recursive(project_path, rename_regex, project_name)
      end

      puts "--- Done!".green
      exit 0
    end
  end
end

begin
  CaffeineLabs::Chan.start(ARGV)
rescue => e
  abort(e.message.red)
end
